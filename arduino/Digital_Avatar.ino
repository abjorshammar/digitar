
#include <FS.h>                   //this needs to be first, or it all crashes and burns...
#include <GxEPD.h>
#include <GxGDEW0154Z04/GxGDEW0154Z04.cpp>
#include <GxIO/GxIO_SPI/GxIO_SPI.cpp>
#include <GxIO/GxIO.cpp>

// FreeFonts from Adafruit_GFX
#include <Fonts/FreeMonoBold9pt7b.h>
#include <Fonts/FreeMonoBold12pt7b.h>
#include <Fonts/FreeMonoBold18pt7b.h>
#include <Fonts/FreeMonoBold24pt7b.h>
#include <Fonts/FreeSansBold12pt7b.h>
#include <Fonts/FreeSans9pt7b.h>

#include "qrcode.h"

#include <DNSServer.h>
#include <ESP8266WebServer.h>
#include <WiFiManager.h>
#include <ArduinoJson.h>

#include <WiFiClientSecure.h>
#include "base64.hpp"

// Define pins
int chargePin = D1;
int battPin = A0;
int battery = 5; // 0 = empty, 2 = 25%, 5 = 50%, 7 = 75%, 10 = 100%, 100 = charging

GxIO_Class io(SPI, SS, 0, 2);
GxEPD_Class display(io);

WiFiClientSecure client;

static const uint8_t PROGMEM wifi_inv [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xf0, 0x01, 0xfc, 0xff, 0xff, 0x07, 0x3f, 0x00,
  0x00, 0x62, 0x40, 0x08, 0x18, 0xf1, 0x01, 0xfc, 0x36, 0xd9, 0x03, 0x3e,
  0x00, 0x00, 0xfe, 0xe0, 0x1f, 0xf8, 0xf1, 0x03, 0x7c, 0x00, 0x00, 0x03,
  0x3e, 0x00, 0x00, 0xfe, 0xe0, 0x1f, 0xfc, 0xf1, 0x03, 0x7c, 0x00, 0x80,
  0x03, 0x3e, 0x00, 0x00, 0xfe, 0xe0, 0x1f, 0xfc, 0xf1, 0x03, 0x7e, 0x00,
  0x00, 0x03, 0x3e, 0x00, 0x00, 0xfc, 0xe0, 0x1f, 0xfc, 0xf1, 0x01, 0x7e,
  0x00, 0x00, 0x07, 0x3f, 0x00, 0x00, 0xfc, 0xe0, 0x3f, 0xfc, 0x01, 0x00,
  0x7c, 0xe0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xe0, 0x3f, 0xfc, 0x00,
  0x00, 0x7e, 0xe0, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xf8, 0xf1, 0x3f, 0xfc,
  0xf0, 0x03, 0x7e, 0xe0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xf8, 0xf1, 0x3f,
  0xfc, 0xf0, 0x01, 0x7c, 0xc0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xf8, 0xf1,
  0x7c, 0x7e, 0xf0, 0x01, 0x7c, 0x00, 0xea, 0x03, 0x3e, 0x00, 0x00, 0xf8,
  0xfb, 0x7d, 0x7e, 0xf0, 0x03, 0x7e, 0x00, 0xe0, 0x03, 0x3e, 0x00, 0x00,
  0xf8, 0xfb, 0x7c, 0x7e, 0xf0, 0x01, 0x7c, 0x00, 0xe0, 0x03, 0x3e, 0x00,
  0x00, 0xf0, 0xfb, 0x7c, 0x7e, 0xf0, 0x01, 0x7c, 0x00, 0xe0, 0x03, 0x3e,
  0x00, 0x00, 0xf0, 0xfb, 0x7c, 0x7e, 0xf0, 0x03, 0x7e, 0x00, 0xe0, 0x03,
  0x3e, 0x00, 0x00, 0xf0, 0xfb, 0x7c, 0x7f, 0xf0, 0x01, 0x7c, 0x40, 0xff,
  0x03, 0x3e, 0x00, 0x00, 0xf0, 0xff, 0xfc, 0x3e, 0xf0, 0x01, 0x7e, 0xc0,
  0xff, 0x03, 0x3e, 0x00, 0x00, 0xe0, 0xff, 0xf8, 0x3f, 0xf0, 0x03, 0x7c,
  0xe0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xe0, 0x7f, 0xf8, 0x3f, 0xf0, 0x03,
  0x7c, 0xe0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xe0, 0xff, 0xf8, 0x1f, 0xf0,
  0x01, 0x7c, 0xc0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xc0, 0x7f, 0xf0, 0x1f,
  0xf0, 0x03, 0x7c, 0xe0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xc0, 0x7f, 0xf0,
  0x1f, 0xf0, 0x03, 0x7c, 0xe0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xc0, 0x3f,
  0xf0, 0x0f, 0xf0, 0x01, 0x7e, 0xc0, 0xff, 0x03, 0x3e, 0x00, 0x00, 0xc0,
  0x3f, 0xe0, 0x0f, 0xf0, 0x01, 0x7e, 0xe0, 0xff, 0x03, 0x3e, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x3f, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x3f,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
  0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
  0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
  0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff,
  0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
  0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

static const uint8_t PROGMEM wifi [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x03, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x07, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x3f, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x7f, 0x00, 0x00, 0x00, 0xfe, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xfc, 0x01, 0xf8, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x01, 0xfc, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0xf0, 0x03, 0xfe, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x07, 0xfe,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0x03, 0x00, 0x00, 0xf8, 0xc0, 0x07,
  0xfe, 0x9d, 0xbf, 0xf7, 0xe7, 0x0e, 0xfe, 0x03, 0xc9, 0x26, 0xfc, 0xc1,
  0x07, 0xfe, 0x01, 0x1f, 0xe0, 0x07, 0x0e, 0xfc, 0x83, 0xff, 0xff, 0xfc,
  0xc1, 0x07, 0xfe, 0x01, 0x1f, 0xe0, 0x03, 0x0e, 0xfc, 0x83, 0xff, 0x7f,
  0xfc, 0xc1, 0x07, 0xfe, 0x01, 0x1f, 0xe0, 0x03, 0x0e, 0xfc, 0x81, 0xff,
  0xff, 0xfc, 0xc1, 0x07, 0xfe, 0x03, 0x1f, 0xe0, 0x03, 0x0e, 0xfe, 0x81,
  0xff, 0xff, 0xf8, 0xc0, 0x07, 0xfe, 0x03, 0x1f, 0xc0, 0x03, 0xfe, 0xff,
  0x83, 0x1f, 0x00, 0x00, 0xc0, 0x07, 0xfe, 0x03, 0x1f, 0xc0, 0x03, 0xff,
  0xff, 0x81, 0x1f, 0x00, 0x00, 0xc0, 0x07, 0xfe, 0x07, 0x0e, 0xc0, 0x03,
  0x0f, 0xfc, 0x81, 0x1f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x07, 0x0e, 0xc0,
  0x03, 0x0f, 0xfe, 0x83, 0x3f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x07, 0x0e,
  0x83, 0x81, 0x0f, 0xfe, 0x83, 0xff, 0x15, 0xfc, 0xc1, 0x07, 0xfe, 0x07,
  0x04, 0x82, 0x81, 0x0f, 0xfc, 0x81, 0xff, 0x1f, 0xfc, 0xc1, 0x07, 0xfe,
  0x07, 0x04, 0x83, 0x81, 0x0f, 0xfe, 0x83, 0xff, 0x1f, 0xfc, 0xc1, 0x07,
  0xfe, 0x0f, 0x04, 0x83, 0x81, 0x0f, 0xfe, 0x83, 0xff, 0x1f, 0xfc, 0xc1,
  0x07, 0xfe, 0x0f, 0x04, 0x83, 0x81, 0x0f, 0xfc, 0x81, 0xff, 0x1f, 0xfc,
  0xc1, 0x07, 0xfe, 0x0f, 0x04, 0x83, 0x80, 0x0f, 0xfe, 0x83, 0xbf, 0x00,
  0xfc, 0xc1, 0x07, 0xfe, 0x0f, 0x00, 0x03, 0xc1, 0x0f, 0xfe, 0x81, 0x3f,
  0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x1f, 0x00, 0x07, 0xc0, 0x0f, 0xfc, 0x83,
  0x1f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x1f, 0x80, 0x07, 0xc0, 0x0f, 0xfc,
  0x83, 0x1f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x1f, 0x00, 0x07, 0xe0, 0x0f,
  0xfe, 0x83, 0x3f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x3f, 0x80, 0x0f, 0xe0,
  0x0f, 0xfc, 0x83, 0x1f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x3f, 0x80, 0x0f,
  0xe0, 0x0f, 0xfc, 0x83, 0x1f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x3f, 0xc0,
  0x0f, 0xf0, 0x0f, 0xfe, 0x81, 0x3f, 0x00, 0xfc, 0xc1, 0x07, 0xfe, 0x3f,
  0xc0, 0x1f, 0xf0, 0x0f, 0xfe, 0x81, 0x1f, 0x00, 0xfc, 0xc1, 0x07, 0xfe,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x07,
  0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc0,
  0x07, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
  0xf0, 0x03, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
  0x00, 0xf0, 0x03, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00,
  0x00, 0x00, 0xf8, 0x01, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00,
  0x00, 0x00, 0x00, 0xfe, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
  0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xfe, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0xf8,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

// Envelope
static const uint8_t PROGMEM envelope[] = {
  0xfc, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x03, 0x57, 0x55, 0xd5, 0x03,
  0x07, 0x00, 0x00, 0x03, 0x03, 0x00, 0x80, 0x03, 0x07, 0x00, 0x80, 0x03,
  0x1f, 0x00, 0xc0, 0x03, 0x3f, 0x00, 0xf0, 0x03, 0x77, 0x00, 0xb8, 0x03,
  0xe3, 0x00, 0x1c, 0x03, 0xc7, 0x03, 0x8f, 0x03, 0x83, 0x87, 0x07, 0x03,
  0x07, 0xef, 0x83, 0x03, 0x03, 0xfc, 0x00, 0x03, 0x07, 0x38, 0x80, 0x03,
  0x03, 0x00, 0x00, 0x03, 0x07, 0x00, 0x80, 0x03, 0xaf, 0xaa, 0xaa, 0x03,
  0xfe, 0xff, 0xff, 0x03, 0xfc, 0xff, 0xff, 0x00 };

// Home office
static const uint8_t PROGMEM homeoffice[] = {
  0x00, 0x00, 0x80, 0x00, 0xd8, 0x00, 0x00, 0x00, 0xe0, 0x07, 0xfc, 0x00,
  0x00, 0x00, 0xf0, 0x0f, 0xfc, 0x01, 0x00, 0x00, 0xf8, 0x1f, 0xfc, 0x00,
  0x00, 0x00, 0xfc, 0x3f, 0xfc, 0x01, 0x00, 0x00, 0xff, 0xff, 0xfc, 0x00,
  0x00, 0x80, 0xff, 0xfe, 0xfd, 0x01, 0x00, 0xc0, 0x3f, 0xfc, 0xff, 0x00,
  0x00, 0xe0, 0x1f, 0xf8, 0xff, 0x01, 0x00, 0xf0, 0x0f, 0xf0, 0xff, 0x00,
  0x00, 0xfc, 0x83, 0xc1, 0xff, 0x01, 0x00, 0xfe, 0xc3, 0x83, 0xff, 0x00,
  0x00, 0xff, 0xf0, 0x0f, 0xff, 0x01, 0x80, 0x7f, 0xf8, 0x1f, 0xfe, 0x01,
  0xc0, 0x3f, 0xfc, 0x3f, 0xfc, 0x03, 0xf0, 0x1f, 0xfe, 0x7f, 0xf8, 0x0f,
  0xf8, 0x07, 0xff, 0xff, 0xe0, 0x1f, 0xfc, 0xc3, 0xff, 0xff, 0xc3, 0x3f,
  0xfe, 0xe1, 0xff, 0xff, 0x87, 0x7f, 0xff, 0xf0, 0xff, 0xff, 0x0f, 0xff,
  0x7e, 0xf8, 0xff, 0xff, 0x1f, 0x7e, 0x1c, 0xfc, 0xff, 0xff, 0x3f, 0x38,
  0x0c, 0xff, 0xff, 0xff, 0xff, 0x30, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00,
  0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0xff, 0x00,
  0x00, 0xff, 0x9f, 0xf4, 0xff, 0x01, 0x80, 0xff, 0x0f, 0xf0, 0xff, 0x00,
  0x80, 0xff, 0x0f, 0xf0, 0xff, 0x01, 0x00, 0xff, 0x0f, 0xf0, 0xff, 0x00,
  0x80, 0xff, 0x0f, 0xf0, 0xff, 0x01, 0x80, 0xff, 0x0f, 0xf0, 0xff, 0x00,
  0x00, 0xff, 0x0f, 0xf0, 0xff, 0x01, 0x80, 0xff, 0x0f, 0xf0, 0xff, 0x00,
  0x80, 0xff, 0x0f, 0xf0, 0xff, 0x01, 0x00, 0xff, 0x0f, 0xf0, 0xff, 0x00,
  0x80, 0xff, 0x0f, 0xf0, 0xff, 0x00, 0x00, 0xfe, 0x0f, 0xf0, 0xff, 0x00
  };

static const uint8_t PROGMEM battery_charging[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xef, 0x03, 0xc0, 0xef, 0x03, 0xc0, 0xe7, 0x03, 0xc0, 0xe7, 0x03,
  0xc0, 0xe3, 0x03, 0xc0, 0xc3, 0x03, 0xc0, 0xc3, 0x03, 0xc0, 0xe7, 0x03,
  0xc0, 0xe7, 0x03, 0xc0, 0xf7, 0x03, 0xc0, 0xf7, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const uint8_t PROGMEM battery_full[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const uint8_t PROGMEM battery_75[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const uint8_t PROGMEM battery_50[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const uint8_t PROGMEM battery_25[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static const uint8_t PROGMEM battery_empty[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03, 0xc0, 0x00, 0x03,
  0xc0, 0xff, 0x03, 0xc0, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

void drawStatusWindow(const uint8_t *avatar, String ticket, int battery) {
  display.fillScreen(GxEPD_WHITE);

  // Draw grid
  display.drawFastVLine(100, 0, 100, GxEPD_BLACK);
  display.drawFastHLine(0, 100, 200, GxEPD_BLACK);
  display.drawFastHLine(0, 130, 200, GxEPD_BLACK);

  // Draw avatar
  display.drawXBitmap(0, 0, avatar, 100, 100, GxEPD_BLACK);

  // Draw battery status
  if (battery == 100) {
    display.drawXBitmap(180, 0, battery_charging, 24, 24, GxEPD_BLACK);
  } else if (battery == 10) {
     display.drawXBitmap(180, 0, battery_full, 24, 24, GxEPD_BLACK);
  } else if (battery == 7) {
     display.drawXBitmap(180, 0, battery_75, 24, 24, GxEPD_BLACK);
  } else if (battery == 5) {
     display.drawXBitmap(180, 0, battery_50, 24, 24, GxEPD_BLACK);
  } else if (battery == 2) {
     display.drawXBitmap(180, 0, battery_25, 24, 24, GxEPD_BLACK);
  } else if (battery == 0) {
     display.drawXBitmap(180, 0, battery_empty, 24, 24, GxEPD_BLACK);
  }
  
  
  // Draw status
  //display.setFont(&FreeSansBold12pt7b);
  //display.setCursor(105, 42);
  //display.println("H/O");
  //display.drawXBitmap(150, 5, homeoffice, 48, 38, GxEPD_RED);

  // Draw ticket
  display.setFont(&FreeSansBold12pt7b);
  display.setTextColor(GxEPD_BLACK);
  display.setCursor(20, 124);
  display.println(ticket);

  // Draw message
  display.drawXBitmap(5, 135, envelope, 26, 20, GxEPD_BLACK);
  display.setCursor(35, 148);
  display.setFont(&FreeSans9pt7b);
  display.println("Great info about anything");

  // Print buffer
  display.update();
}


void drawLowBatteryWindow() {
  display.fillScreen(GxEPD_WHITE);
  display.setTextColor(GxEPD_RED);
  display.setFont(&FreeMonoBold24pt7b);
  display.setCursor(3, 70);
  display.println("  LOW  ");
  display.setCursor(3, 110);
  display.println("BATTERY");
  display.setFont(&FreeSans9pt7b);
  display.setTextColor(GxEPD_BLACK);
  display.setCursor(22, 140);
  display.println("Connect to charger");
  display.update();
}


bool charging() {
  if (digitalRead(chargePin) == HIGH) {
    return true;
  }
  else {
    return false;
  }
}

void checkBattery() {
  unsigned int raw = 0;
  float volt = 0.0;
  float adjustment = 0.2;
  raw = analogRead(battPin);
  volt = raw / 1023.0;
  volt = volt * 4.2 + adjustment;
  String volts = " volts";
  String v = String(volt + volts);
  Serial.println(v);

  if (volt >= 4.2) {
    battery = 10;
  } else if (volt > 4.1 && volt < 3.9) {
    battery = 7;
  } else if (volt > 3.9 && volt < 3.8) {
    battery = 5;
  } else if (volt > 3.8 && volt < 3.7) {
    battery = 2;
  } else if (volt < 3.7) {
    battery = 0;
  }

  // If volt is too low, update display and go back to sleep for 60 minutes
  float lowVoltCutoff = 3.5;
  if (volt <= lowVoltCutoff) {
    Serial.println("Voltage low, going back to sleep");
    drawLowBatteryWindow();
    ESP.deepSleep(3600 * 1000000);
    Serial.println("Sleep failed!");
  }
  
}


void drawQrCode(String header1, String header2, String text) {
  QRCode qrcode;
  uint8_t qrcodeData[qrcode_getBufferSize(5)];
  qrcode_initText(&qrcode, qrcodeData, 5, ECC_HIGH, text.c_str());

  display.fillScreen(GxEPD_WHITE);
  display.setFont(&FreeMonoBold9pt7b);
  display.setTextColor(GxEPD_BLACK);
  display.setCursor(3, 18);
  display.println(header1.c_str());
  display.setCursor(3, 32);
  display.println(header2.c_str());


  for (uint8_t y = 0; y < qrcode.size; y++) {
    for (uint8_t x = 0; x < qrcode.size; x++) {
      if (qrcode_getModule(&qrcode, x, y)) {
        display.fillRect(x * 4 + 26, y * 4 + 47, 4, 4, GxEPD_BLACK);
      }
    }
  }
  display.drawXBitmap(50, 100, wifi_inv, 100, 48, GxEPD_WHITE);
  display.drawXBitmap(50, 100, wifi, 100, 48, GxEPD_RED);

  display.update();
  delay(5000);
}

String ssid;
String pw;
String qr_code;

void configModeCallback (WiFiManager *myWiFiManager) {
  drawQrCode("SSID: " + ssid, "Password: " + pw, qr_code);
}

char aws_key[255];
char aws_secret[255];

bool shouldSaveConfig = false;

//callback notifying us of the need to save config
void saveConfigCallback () {
  Serial.println("Should save config");
  shouldSaveConfig = true;
}

void setup_aws() {
  Serial.println("mounting FS...");

  if (SPIFFS.begin()) {
    Serial.println("mounted file system");
    if (SPIFFS.exists("/config.json")) {
      //file exists, reading and loading
      Serial.println("reading config file");
      File configFile = SPIFFS.open("/config.json", "r");
      if (configFile) {
        Serial.println("opened config file");
        size_t size = configFile.size();
        // Allocate a buffer to store contents of the file.
        std::unique_ptr<char[]> buf(new char[size]);

        configFile.readBytes(buf.get(), size);
        DynamicJsonBuffer jsonBuffer;
        JsonObject& json = jsonBuffer.parseObject(buf.get());
        json.printTo(Serial);
        if (json.success()) {
          Serial.println("\nparsed json");

          strcpy(aws_key, json["aws_key"]);
          strcpy(aws_secret, json["aws_secret"]);

        } else {
          Serial.println("failed to load json config");
        }
      }
    }
  } else {
    Serial.println("failed to mount FS");
  }
}

unsigned char* avatar;
unsigned char* binary;


void setup() {
  // Start serial
  Serial.begin(115200);
  Serial.println();
  Serial.println("Setup");

  // Pin modes
  pinMode(chargePin, INPUT);
  pinMode(battPin, INPUT);
  pinMode(D0, WAKEUP_PULLUP);


  // Start display
  display.init();

  // variables
  const int sleepSeconds = 60; // 1800 = 30 minutes
  randomSeed(RANDOM_REG32);
  long randNumber = random(100, 999);
  Serial.print("random2=");
  Serial.print(randNumber);
  ssid = String("Digitar") + String(randNumber);
  long password = random(10000000, 99999999);
  pw = String(password);
  qr_code = String("WIFI:S:") + ssid + String(";T:WPA;P:") + pw + String(";;");

  // Check for low battery and charging status
  if (charging() == true) {
    Serial.println("Charging");
    battery = 100;
  } else {
    Serial.println("Not charging");
    checkBattery();
  }

  // Setup AWS
  setup_aws();

  // Setup AWS params in WiFiManager
  WiFiManagerParameter custom_aws_key("key", "Jira user", aws_key, 255);
  WiFiManagerParameter custom_aws_secret("secret", "Digitar password", aws_secret, 255);

  // Setup wifimanager
  WiFiManager wifiManager;
  // TODO: allow WiFi reset somehow.
  // wifiManager.resetSettings();
  wifiManager.addParameter(&custom_aws_key);
  wifiManager.addParameter(&custom_aws_secret);
  wifiManager.setAPCallback(configModeCallback);
  wifiManager.setSaveConfigCallback(saveConfigCallback);
  wifiManager.autoConnect(ssid.c_str(), pw.c_str());

  strcpy(aws_key, custom_aws_key.getValue());
  strcpy(aws_secret, custom_aws_secret.getValue());

  // Save entered config
  if (shouldSaveConfig) {
    Serial.println("saving config");
    DynamicJsonBuffer jsonBuffer;
    JsonObject& json = jsonBuffer.createObject();
    json["aws_key"] = aws_key;
    json["aws_secret"] = aws_secret;

    File configFile = SPIFFS.open("/config.json", "w");
    if (!configFile) {
      Serial.println("failed to open config file for writing");
    }

    json.printTo(Serial);
    json.printTo(configFile);
    configFile.close();
    //end save
  }

  Serial.println("Setup done");
}

char* buffer;
int buffer_len = 0;

String fetch() {
  String body = "";
  bool finishedHeaders = false;
  bool currentLineIsBlank = true;
  bool gotResponse = false;
  long now;

  buffer = (char*)malloc(2048);
  memset(buffer, 1, 0);
  buffer_len = 0;

  char host[] = "5omnzjyeva.execute-api.eu-west-1.amazonaws.com"; // Replace xxxx with correct end-point

  Serial.println("connecting");
  if (client.connect(host, 443))
  {
    Serial.println("connected");

    String URL = "/prod/digitar/get?key=test";

    Serial.println(URL);

    client.println("GET " + URL + " HTTP/1.1");
    client.print("Host: ");
    client.println(host);
    client.println("User-Agent: arduino/1.0");
    client.println("Content-Type: application/json");

    client.println("");

    now = millis();

    while (!client.available()) {
      delay(100);
    }

    Serial.println("Client connected");

    while (client.available())
    {

      char c = client.read();

      if (finishedHeaders)
      {
        buffer[buffer_len++] = c;
      }
      else
      {
        if (currentLineIsBlank && c == '\n')
        {
          finishedHeaders = true;
          Serial.println("\nFinished headers");
        }
      }

      if (c == '\n')
      {
        currentLineIsBlank = true;
      }
      else if (c != '\r')
      {
        currentLineIsBlank = false;
      }

      gotResponse = true;
    }
    if (gotResponse) {
      Serial.println("\nBody: " + body);
      return body;
    }
  }

  Serial.println("No HTTP resp");

  return body;
}
 

bool found = false;
String issueNr = "";

char key[255] = "";

void loop() {
  // Are we charging
  if (charging() == true) {
    Serial.println("Charging");
  } else {
    Serial.println("Not charging");
  }

  Serial.println("Before URL GET");

  if(!found) {
    
    Serial.println("URL GET");
    fetch();
    Serial.println("Fetched body");

    DynamicJsonBuffer jsonBuffer;
    JsonObject& json = jsonBuffer.parseObject(buffer);
    free(buffer);
    json.printTo(Serial);
    if (json.success()) {
          avatar = (unsigned char*) malloc(2048);
          Serial.println("\nparsed json");
          strcpy(key, json["key"]);
          strcpy((char*)avatar, json["avatar"]);
          found = true;
          issueNr = key;
          Serial.println("Decode avatar");
          binary = (unsigned char*) malloc(2048);
          unsigned int binary_length = decode_base64(avatar, binary);
          Serial.println("Decoded avatar mem");
    }
    else {
          Serial.println("\nYour json is a joke!"); 
    }
  }

  if(found) {
    drawStatusWindow(binary, issueNr, battery);
    Serial.println("Drawn avatar. Will sleep.");
    ESP.deepSleep(3600 * 1000000);
    Serial.println("Sleep failed!");
  }
  else {
      display.fillScreen(GxEPD_WHITE);
      display.setFont(&FreeMonoBold9pt7b);
      display.setTextColor(GxEPD_BLACK);
      display.setCursor(3, 18);
      display.println("Failed to fetch status");      
  }

  delay(5000);
}
